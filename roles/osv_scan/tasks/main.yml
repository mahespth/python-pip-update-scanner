---

- name: Ensure export directory exists on controller
  ansible.builtin.file:
    path: "{{ requirements_export_dir }}"
    state: directory
    mode: "0755"
  delegate_to: localhost
  run_once: true

- name: Find python3* interpreters under /usr/bin (RHEL rpm-based)
  ansible.builtin.find:
    paths: /usr/bin
    patterns: "python3*"
    file_type: file
  register: py_bins

- name: Filter real python interpreters (python3, python3.X)
  ansible.builtin.set_fact:
    python_interpreters: >-
      {{ py_bins.files
        | map(attribute='path')
        | select('regex', 'python3(\\.[0-9]+)?$')
        | list }}

- name: Show discovered interpreters (for sanity)
  ansible.builtin.debug:
    var: python_interpreters

- name: Gather package list for each interpreter (pip list, no changes)
  ansible.builtin.command: >
    {{ item }} -m pip list --format=freeze
  register: pip_lists
  loop: "{{ python_interpreters }}"
  failed_when: false
  changed_when: false

- name: Also capture interpreter versions (for naming)
  ansible.builtin.command: >
    {{ item }} -c "import sys; print('.'.join(map(str, sys.version_info[:3])))"
  register: py_versions
  loop: "{{ python_interpreters }}"
  failed_when: false
  changed_when: false

- name: Build mapping of interpreter -> version
  ansible.builtin.set_fact:
    py_interp_info: >-
      {{
        dict(
          python_interpreters
          | zip(
              py_versions.results
              | map(attribute='stdout')
              | list
            )
        )
      }}

- name: Save requirements snapshots on controller (one per interpreter)
  vars:
    interp_path: "{{ item.item }}"
    interp_version: "{{ py_interp_info[interp_path] | default('unknown') }}"
    safe_interp: "{{ interp_path | basename }}"
  delegate_to: localhost
  ansible.builtin.copy:
    content: "{{ item.stdout }}"
    dest: "{{ requirements_export_dir }}/{{ inventory_hostname }}-{{ safe_interp }}-py{{ interp_version }}.requirements.txt"
  loop: "{{ pip_lists.results }}"
  when: item.rc == 0 and item.stdout != ""
  changed_when: false

- name: Find requirements snapshots
  ansible.builtin.find:
    paths: "{{ requirements_export_dir }}"
    patterns: "*.requirements.txt"
  register: req_files
  delegate_to: localhost
  run_once: true

- name: Run osv-scanner (offline) for each snapshot
  ansible.builtin.command: >
    {{ osv_scanner_path }} scan
    --offline-vulnerabilities
    -L {{ item.path }}
    --format json
  environment:
    OSV_SCANNER_LOCAL_DB_CACHE_DIRECTORY: "{{ osv_db_dir }}"
  loop: "{{ req_files.files }}"
  register: osv_results
  changed_when: false
  delegate_to: localhost
  run_once: true

- name: Summarise vulnerabilities per host+interpreter
  vars:
    base: "{{ item.item.path | basename }}"
    host_name: "{{ base.split('-')[0] }}"
    interp_label: "{{ base.split('-')[1] | default('python3') }}"
    parsed: "{{ (item.stdout | default('{}')) | from_json }}"
    vuln_count: "{{ parsed.results | length if parsed.results is defined else 0 }}"
  ansible.builtin.debug:
    msg: >
      {{ host_name }} / {{ interp_label }}:
      {{ vuln_count }} vulnerable packages found
  loop: "{{ osv_results.results }}"
  delegate_to: localhost
  run_once: true

- name: Fail if any snapshot has vulnerabilities (optional)
  vars:
    any_vulns: >-
      {{ osv_results.results
        | selectattr('stdout', 'defined')
        | map(attribute='stdout')
        | map('from_json')
        | map(attribute='results')
        | map('length')
        | select('>', 0)
        | list
        | length > 0 }}
  ansible.builtin.fail:
    msg: "One or more Python interpreters have vulnerabilities (see debug output above)."
  when: any_vulns
  ignore_errors: false
  delegate_to: localhost
  run_once: true
  tags:
    - enforce

...